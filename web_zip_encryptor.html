<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>웹 기반 ZIP 암호화 프로그램</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; padding: 20px; max-width: 600px; margin: auto; }
        h1 { color: #333; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="file"], input[type="password"], input[type="text"] { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 4px; }
        button { background-color: #007bff; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status { margin-top: 20px; font-weight: bold; color: #28a745; }
    </style>
</head>
<body>

    <h1>웹 기반 ZIP 암호화 프로그램</h1>
    <p>새로운 ZIP 파일을 만들거나, 기존 ZIP 파일에 파일을 추가할 수 있습니다. 모든 과정은 브라우저 내에서 안전하게 처리됩니다.</p>

    <div class="control-group">
        <label for="existing-zip-input">1. (선택) 기존 ZIP 파일에 추가하기:</label>
        <input type="file" id="existing-zip-input" accept=".zip">
    </div>

    <div class="control-group">
        <label for="file-input">2. 압축하거나 추가할 파일 또는 폴더 선택:</label>
        <input type="file" id="file-input" multiple webkitdirectory>
    </div>

    <div class="control-group">
        <label for="password-input">3. 설정할 암호 입력:</label>
        <input type="password" id="password-input" placeholder="암호를 잊지 않도록 주의하세요">
    </div>

    <div class="control-group">
        <label for="zip-name-input">4. 생성할 ZIP 파일 이름 (확장자 제외):</label>
        <input type="text" id="zip-name-input" value="encrypted-archive">
    </div>

    <button id="zip-button">암호화 압축 시작</button>

    <div id="status"></div>

    <!-- zip.js 라이브러리를 CDN을 통해 불러옵니다 -->
    <script src="https://unpkg.com/@zip.js/zip.js@2.7.47/dist/zip.min.js"></script>

    <script>
        const fileInput = document.getElementById('file-input');
        const existingZipInput = document.getElementById('existing-zip-input');
        const passwordInput = document.getElementById('password-input');
        const zipNameInput = document.getElementById('zip-name-input');
        const zipButton = document.getElementById('zip-button');
        const statusDiv = document.getElementById('status');

        // zip.js 라이브러리에서 필요한 객체들을 가져옵니다.
        const { BlobWriter, BlobReader, ZipWriter, ZipReader } = zip;

        // '기존 ZIP 파일' 입력이 변경될 때 파일 이름을 자동으로 설정하는 이벤트 리스너
        existingZipInput.addEventListener('change', () => {
            const existingZipFile = existingZipInput.files[0];
            if (existingZipFile) {
                const fileName = existingZipFile.name;
                // 파일 이름에서 마지막 '.zip' 확장자를 제거합니다.
                const baseName = fileName.toLowerCase().endsWith('.zip') ? fileName.slice(0, -4) : fileName;
                zipNameInput.value = baseName;
            }
        });

        zipButton.addEventListener('click', async () => {
            // 1. 입력 값 유효성 검사
            if (fileInput.files.length === 0 && existingZipInput.files.length === 0) {
                alert('압축할 파일을 선택하거나 기존 ZIP 파일을 선택해주세요.');
                return;
            }
            const password = passwordInput.value;
            if (!password) {
                alert('ZIP 파일에 사용할 암호를 입력해주세요.');
                return;
            }
            const zipName = zipNameInput.value.trim() || 'encrypted-archive';

            // 2. 버튼 비활성화 및 상태 메시지 초기화
            zipButton.disabled = true;
            statusDiv.textContent = '파일을 처리하는 중...';

            try {
                // 3. zip.js를 사용하여 암호화 압축 실행
                // 3-1. 압축된 데이터를 저장할 BlobWriter를 생성합니다.
                const zipWriter = new ZipWriter(new BlobWriter("application/zip"), {
                    // Windows 기본 압축 해제 기능과 호환되도록 레거시 ZipCrypto 암호화를 사용합니다.
                    // 이 방식은 AES 암호화보다 보안에 취약할 수 있습니다.
                    zipCrypto: true,
                    password: password, // 암호 설정
                });

                // 3-2. 기존 zip 파일이 있으면 먼저 추가합니다.
                const existingZipFile = existingZipInput.files[0];
                if (existingZipFile) {
                    statusDiv.textContent = '기존 ZIP 파일을 읽는 중...';
                    const zipReader = new ZipReader(new BlobReader(existingZipFile));
                    // 암호가 있는 경우, getEntries 호출 시 암호 제공
                    const entries = await zipReader.getEntries({ password });
                    for (const entry of entries) {
                        // 1. 항목의 데이터를 임시로 저장할 BlobWriter를 생성합니다.
                        const dataWriter = new BlobWriter();
                        // 2. entry.getData에 dataWriter를 제공하여 압축 해제된 데이터를 쓰게 합니다.
                        await entry.getData(dataWriter, { password });
                        // 3. dataWriter에서 결과 Blob을 가져옵니다.
                        const data = await dataWriter.getData();
                        await zipWriter.add(entry.filename, new BlobReader(data));
                    }
                    await zipReader.close();
                }

                // 3-3. 새로 추가할 파일들을 순회하며 zip에 추가합니다.
                if (fileInput.files.length > 0) {
                    statusDiv.textContent = '새 파일을 추가하는 중...';
                }
                for (const file of fileInput.files) {
                    // webkitRelativePath를 사용하여 폴더 구조를 유지합니다.
                    const pathInZip = file.webkitRelativePath || file.name;
                    await zipWriter.add(pathInZip, new BlobReader(file));
                }

                // 3-3. 압축을 완료하고 최종 Blob 데이터를 가져옵니다.
                const zipBlob = await zipWriter.close();

                // 4. 압축 성공 시 다운로드 링크 생성
                statusDiv.textContent = '암호화 압축 완료! 다운로드를 시작합니다.';

                // 다운로드용 임시 링크 생성
                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                link.download = `${zipName}.zip`; // 최종 파일명 설정

                // 링크를 클릭하여 다운로드 실행 및 제거
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                URL.revokeObjectURL(link.href); // 메모리 관리

                // 작업 완료 후 파일 입력 필드 초기화
                fileInput.value = '';
                existingZipInput.value = '';

            } catch (error) {
                statusDiv.textContent = `오류: ${error.message}`;
                console.error(error);
            } finally {
                // 5. 버튼 다시 활성화
                zipButton.disabled = false;
            }
        });
    </script>

</body>
</html>
